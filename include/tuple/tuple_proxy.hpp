// Copyright (c) 2017-2019 Florian Wende (flwende@gmail.com)
//
// Distributed under the BSD 2-clause Software License
// (See accompanying file LICENSE)

#if !defined(TUPLE_TUPLE_PROXY_HPP)
#define TUPLE_TUPLE_PROXY_HPP

#if !defined(XXX_NAMESPACE)
#define XXX_NAMESPACE fw
#endif

#if !defined(TUPLE_NAMESPACE)
#define TUPLE_NAMESPACE XXX_NAMESPACE
#endif

namespace TUPLE_NAMESPACE
{
    namespace internal
    {
        template <typename T_1, typename T_2, typename T_3>
        class tuple_proxy
        {
            static_assert(std::is_fundamental<T_1>::value, "error: T_1 is not a fundamental data type");
            static_assert(!std::is_void<T_1>::value, "error: T_1 is void -> not allowed");
            static_assert(!std::is_volatile<T_1>::value, "error: T_1 is volatile -> not allowed");

            static_assert(std::is_fundamental<T_2>::value, "error: T_2 is not a fundamental data type");
            static_assert(!std::is_void<T_2>::value, "error: T_2 is void -> not allowed");
            static_assert(!std::is_volatile<T_2>::value, "error: T_2 is volatile -> not allowed");

            static_assert(std::is_fundamental<T_3>::value, "error: T_3 is not a fundamental data type");
            static_assert(!std::is_void<T_3>::value, "error: T_3 is void -> not allowed");
            static_assert(!std::is_volatile<T_3>::value, "error: T_3 is volatile -> not allowed");

        public:

            // some meta data: to be generated by the proxy generator
            using type = tuple_proxy<T_1, T_2, T_3>;
            using const_type = tuple_proxy<const T_1, const T_2, const T_3>;
            using T_1_unqualified = typename std::remove_cv<T_1>::type;
            using T_2_unqualified = typename std::remove_cv<T_2>::type;
            using T_3_unqualified = typename std::remove_cv<T_3>::type;

            struct memory
            {
                // some meta data: to be generated by the proxy generator
                static constexpr bool is_homogeneous = (sizeof(T_1) == sizeof(T_2) && sizeof(T_1) == sizeof(T_3));
                static constexpr std::size_t size_largest_type = std::max(sizeof(T_1), std::max(sizeof(T_2), sizeof(T_3)));
                static constexpr std::size_t size_rest = 
                    (sizeof(T_1) == size_largest_type ? 0UL : sizeof(T_1)) +
                    (sizeof(T_2) == size_largest_type ? 0UL : sizeof(T_2)) +
                    (sizeof(T_3) == size_largest_type ? 0UL : sizeof(T_3));
                // relation to the greatest common divisor: lcm(a, b) = (a * b) / gcd(a, b)                                                     
                static constexpr std::size_t record_padding_factor = AUXILIARY_NAMESPACE::least_common_multiple(size_largest_type, size_rest) / std::max(1UL, size_rest);
                static constexpr std::size_t record_size = sizeof(T_1) + sizeof(T_2) + sizeof(T_3);

                static constexpr std::size_t unit_factor_T_1 = size_largest_type / sizeof(T_1);
                static constexpr std::size_t unit_factor_T_2 = size_largest_type / sizeof(T_2);
                static constexpr std::size_t unit_factor_T_3 = size_largest_type / sizeof(T_3);

                const std::size_t num_units;
                T_1* __restrict__ ptr_1;
                T_2* __restrict__ ptr_2;
                T_3* __restrict__ ptr_3;

                memory(std::uint8_t* __restrict__ ptr, const std::size_t n_innermost)
                    :
                    num_units((n_innermost * (sizeof(T_1) + sizeof(T_2) + sizeof(T_3))) / size_largest_type),
                    ptr_1(reinterpret_cast<T_1*>(&ptr[0])),
                    ptr_2(reinterpret_cast<T_2*>(&ptr[n_innermost * sizeof(T_1)])),
                    ptr_3(reinterpret_cast<T_3*>(&ptr[n_innermost * (sizeof(T_1) + sizeof(T_2))])) 
                { ; }


                memory(const typename tuple_proxy<T_1_unqualified, T_2_unqualified, T_3_unqualified>::memory& m)
                    :
                    num_units(m.num_units),
                    ptr_1(m.ptr_1),
                    ptr_2(m.ptr_2),
                    ptr_3(m.ptr_3)
                { ; }

                memory(const typename tuple_proxy<const T_1_unqualified, const T_2_unqualified, const T_3_unqualified>::memory& m)
                    :
                    num_units(m.num_units),
                    ptr_1(m.ptr_1),
                    ptr_2(m.ptr_2),
                    ptr_3(m.ptr_3)
                { ; }

                memory(const memory& m, const std::size_t slice_idx, const std::size_t idx)
                    :
                    num_units(m.num_units),
                    ptr_1(&m.ptr_1[slice_idx * num_units * unit_factor_T_1 + idx]),
                    ptr_2(&m.ptr_2[slice_idx * num_units * unit_factor_T_2 + idx]),
                    ptr_3(&m.ptr_3[slice_idx * num_units * unit_factor_T_3 + idx])
                { ; }

                memory at(const std::size_t slice_idx, const std::size_t idx)
                {
                    return memory(*this, slice_idx, idx);
                }

                memory at(const std::size_t slice_idx, const std::size_t idx) const
                {
                    return memory(*this, slice_idx, idx);
                }

                // replace by internal alignment
                static std::size_t padding(const std::size_t n, const std::size_t alignment = SIMD_NAMESPACE::simd::alignment)
                {
                    if (!AUXILIARY_NAMESPACE::is_power_of<2>(alignment))
                    {
                        std::cerr << "warning: alignment is not a power of 2" << std::endl;
                        return n;
                    }

                    const std::size_t byte_padding_factor = std::max(1UL, alignment / size_largest_type);
                    const std::size_t ratio = (is_homogeneous ? byte_padding_factor : AUXILIARY_NAMESPACE::least_common_multiple(record_padding_factor, byte_padding_factor));

                    return ((n + ratio - 1) / ratio) * ratio;
                }

                template <std::size_t D>
                static std::uint8_t* allocate(const sarray<std::size_t, D>& n, const std::size_t alignment = SIMD_NAMESPACE::simd::alignment)
                {
                    if (n[0] != padding(n[0], alignment))
                    {
                        std::cerr << "error in vec_proxy::memory::allocate : n[0] does not match alignment" << std::endl;
                    }

                    return reinterpret_cast<std::uint8_t*>(_mm_malloc(n.reduce_mul() * record_size, alignment));
                }

                static void deallocate(memory& m)
                {
                    if (m.ptr_1)
                    {
                        _mm_free(reinterpret_cast<std::uint8_t*>(m.ptr_1));
                    }
                }
            };

            T_1& x;
            T_2& y;
            T_3& z;

            tuple_proxy(memory m)
                :
                x(*(m.ptr_1)),
                y(*(m.ptr_2)),
                z(*(m.ptr_3))
            { ; }

        #define MACRO(OP, IN_T)                                                                 \
            inline tuple_proxy& operator OP (TUPLE_NAMESPACE::IN_T<T_1, T_2, T_3>& t)           \
            {                                                                                   \
                x OP t.x;                                                                       \
                y OP t.y;                                                                       \
                z OP t.z;                                                                       \
                return *this;                                                                   \
            }                                                                                   \
                                                                                                \
            inline tuple_proxy& operator OP (const TUPLE_NAMESPACE::IN_T<T_1, T_2, T_3>& t)     \
            {                                                                                   \
                x OP t.x;                                                                       \
                y OP t.y;                                                                       \
                z OP t.z;                                                                       \
                return *this;                                                                   \
            }                                                                                   \
                                                                                                \
            template <typename X_1, typename X_2, typename X_3>                                 \
            inline tuple_proxy& operator OP (TUPLE_NAMESPACE::IN_T<X_1, X_2, X_3>& t)           \
            {                                                                                   \
                x OP t.x;                                                                       \
                y OP t.y;                                                                       \
                z OP t.z;                                                                       \
                return *this;                                                                   \
            }                                                                                   \
                                                                                                \
            template <typename X_1, typename X_2, typename X_3>                                 \
            inline tuple_proxy& operator OP (const TUPLE_NAMESPACE::IN_T<X_1, X_2, X_3>& t)     \
            {                                                                                   \
                x OP t.x;                                                                       \
                y OP t.y;                                                                       \
                z OP t.z;                                                                       \
                return *this;                                                                   \
            }                                                                                   \

            MACRO(=, tuple)
            MACRO(+=, tuple)
            MACRO(-=, tuple)
            MACRO(*=, tuple)
            MACRO(/=, tuple)

            MACRO(=, internal::tuple_proxy)
            MACRO(+=, internal::tuple_proxy)
            MACRO(-=, internal::tuple_proxy)
            MACRO(*=, internal::tuple_proxy)
            MACRO(/=, internal::tuple_proxy)

        #undef MACRO

        #define MACRO(OP)                                                                       \
            template <typename X>                                                               \
            inline tuple_proxy& operator OP (const X xyz)                                       \
            {                                                                                   \
                x OP xyz;                                                                       \
                y OP xyz;                                                                       \
                z OP xyz;                                                                       \
                return *this;                                                                   \
            }                                                                                   \

            MACRO(=)
            MACRO(+=)
            MACRO(-=)
            MACRO(*=)
            MACRO(/=)

        #undef MACRO
        };

        template <typename T_1, typename T_2, typename T_3>
        std::ostream& operator<<(std::ostream& os, const tuple_proxy<T_1, T_2, T_3>& vp)
        {
            os << "(" << static_cast<std::uint64_t>(vp.x) << "," << static_cast<std::uint64_t>(vp.y) << "," << static_cast<std::uint64_t>(vp.z) << ")";
            return os;
        }
    }
}

#endif