// Copyright (c) 2017-2019 Florian Wende (flwende@gmail.com)
//
// Distributed under the BSD 2-clause Software License
// (See accompanying file LICENSE)

#if !defined(TUPLE_TUPLE_HPP)
#define TUPLE_TUPLE_HPP

#include <cstdint>
#include <type_traits>

#if !defined(XXX_NAMESPACE)
#define XXX_NAMESPACE fw
#endif

#if !defined(TUPLE_NAMESPACE)
#define TUPLE_NAMESPACE XXX_NAMESPACE
#endif

#include "../misc/misc_math.hpp"
#include "../misc/misc_memory.hpp"
#include "../common/traits.hpp"

namespace TUPLE_NAMESPACE
{
    // some forward declarations
    namespace internal
    {
        template <typename T_1, typename T_2, typename T_3>
        class tuple_proxy;
    }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//! \brief A simple tuple with 3 components of different type
	//!
	//! \tparam T_1 data type
    //! \tparam T_2 data type
    //! \tparam T_3 data type
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    template <typename T_1, typename T_2, typename T_3>
    class tuple;

    template <typename T_1, typename T_2, typename T_3>
    class tuple
    {
        static_assert(std::is_fundamental<T_1>::value, "error: T_1 is not a fundamental data type");
		static_assert(!std::is_void<T_1>::value, "error: T_1 is void -> not allowed");
        static_assert(!std::is_volatile<T_1>::value, "error: T_1 is volatile -> not allowed");
        static_assert(!std::is_const<T_1>::value, "error: T_1 is const -> not allowed");

        static_assert(std::is_fundamental<T_2>::value, "error: T_2 is not a fundamental data type");
		static_assert(!std::is_void<T_2>::value, "error: T_2 is void -> not allowed");
        static_assert(!std::is_volatile<T_2>::value, "error: T_2 is volatile -> not allowed");
        static_assert(!std::is_const<T_2>::value, "error: T_2 is const -> not allowed");

        static_assert(std::is_fundamental<T_3>::value, "error: T_3 is not a fundamental data type");
		static_assert(!std::is_void<T_3>::value, "error: T_3 is void -> not allowed");
        static_assert(!std::is_volatile<T_3>::value, "error: T_3 is volatile -> not allowed");
        static_assert(!std::is_const<T_3>::value, "error: T_3 is const -> not allowed");

    public:

        using type = tuple<T_1, T_2, T_3>;
        using proxy_type = typename internal::tuple_proxy<T_1, T_2, T_3>;

		tuple() : x(0), y(0), z(0) {}

        template <typename X>
		tuple(const X xyz) : x(xyz), y(xyz), z(xyz) {}
		tuple(const T_1 x, const T_2 y, const T_3 z) : x(x), y(y), z(z) {}

		template <typename X_1, typename X_2, typename X_3>
		tuple(const tuple<X_1, X_2, X_3>& v) : x(v.x), y(v.y), z(v.z) {}
        
		template <typename X_1, typename X_2, typename X_3>
		tuple(const internal::tuple_proxy<X_1, X_2, X_3>& vp) : x(vp.x), y(vp.y), z(vp.z) {}

        T_1 x;
        T_2 y;
        T_3 z;
    };

    template <typename T_1, typename T_2, typename T_3>
	std::ostream& operator<<(std::ostream& os, const tuple<T_1, T_2, T_3>& v)
	{
		os << "(" << static_cast<std::uint64_t>(v.x) << "," << static_cast<std::uint64_t>(v.y) << "," << static_cast<std::uint64_t>(v.z) << ")";
		return os;
	}

    namespace internal
    {
        template <typename T_1, typename T_2, typename T_3>
        class tuple_proxy
        {
            static_assert(std::is_fundamental<T_1>::value, "error: T_1 is not a fundamental data type");
            static_assert(!std::is_void<T_1>::value, "error: T_1 is void -> not allowed");
            static_assert(!std::is_volatile<T_1>::value, "error: T_1 is volatile -> not allowed");

            static_assert(std::is_fundamental<T_2>::value, "error: T_2 is not a fundamental data type");
            static_assert(!std::is_void<T_2>::value, "error: T_2 is void -> not allowed");
            static_assert(!std::is_volatile<T_2>::value, "error: T_2 is volatile -> not allowed");

            static_assert(std::is_fundamental<T_3>::value, "error: T_3 is not a fundamental data type");
            static_assert(!std::is_void<T_3>::value, "error: T_3 is void -> not allowed");
            static_assert(!std::is_volatile<T_3>::value, "error: T_3 is volatile -> not allowed");

        public:
            // some meta data: to be generated by the proxy generator
            using type = tuple_proxy<T_1, T_2, T_3>;
            using const_type = tuple_proxy<const T_1, const T_2, const T_3>;
            using T_1_unqualified = typename std::remove_cv<T_1>::type;
            using T_2_unqualified = typename std::remove_cv<T_2>::type;
            using T_3_unqualified = typename std::remove_cv<T_3>::type;

            struct memory
            {
                // some meta data: to be generated by the proxy generator
                static constexpr bool is_homogeneous = (sizeof(T_1) == sizeof(T_2) && sizeof(T_1) == sizeof(T_3));
                static constexpr std::size_t size_largest_type = std::max(sizeof(T_1), std::max(sizeof(T_2), sizeof(T_3)));
                static constexpr std::size_t size_rest = 
                    (sizeof(T_1) == size_largest_type ? 0UL : sizeof(T_1)) +
                    (sizeof(T_2) == size_largest_type ? 0UL : sizeof(T_2)) +
                    (sizeof(T_3) == size_largest_type ? 0UL : sizeof(T_3));
                // relation to the greatest common divisor: lcm(a, b) = (a * b) / gcd(a, b)                                                     
                static constexpr std::size_t record_padding_factor = MISC_NAMESPACE::least_common_multiple(size_largest_type, size_rest) / std::max(1UL, size_rest);
                static constexpr std::size_t record_size = sizeof(T_1) + sizeof(T_2) + sizeof(T_3);

                static constexpr std::size_t unit_factor_T_1 = size_largest_type / sizeof(T_1);
                static constexpr std::size_t unit_factor_T_2 = size_largest_type / sizeof(T_2);
                static constexpr std::size_t unit_factor_T_3 = size_largest_type / sizeof(T_3);

                const std::size_t num_units;
                T_1* __restrict__ ptr_1;
                T_2* __restrict__ ptr_2;
                T_3* __restrict__ ptr_3;

                memory(std::uint8_t* __restrict__ ptr, const std::size_t n_innermost)
                    :
                    num_units((n_innermost * (sizeof(T_1) + sizeof(T_2) + sizeof(T_3))) / size_largest_type),
                    ptr_1(reinterpret_cast<T_1*>(&ptr[0])),
                    ptr_2(reinterpret_cast<T_2*>(&ptr[n_innermost * sizeof(T_1)])),
                    ptr_3(reinterpret_cast<T_3*>(&ptr[n_innermost * (sizeof(T_1) + sizeof(T_2))])) 
                { ; }


                memory(const typename tuple_proxy<T_1_unqualified, T_2_unqualified, T_3_unqualified>::memory& m)
                    :
                    num_units(m.num_units),
                    ptr_1(m.ptr_1),
                    ptr_2(m.ptr_2),
                    ptr_3(m.ptr_3)
                { ; }

                memory(const typename tuple_proxy<const T_1_unqualified, const T_2_unqualified, const T_3_unqualified>::memory& m)
                    :
                    num_units(m.num_units),
                    ptr_1(m.ptr_1),
                    ptr_2(m.ptr_2),
                    ptr_3(m.ptr_3)
                { ; }

                memory(const memory& m, const std::size_t slice_idx, const std::size_t idx)
                    :
                    num_units(m.num_units),
                    ptr_1(&m.ptr_1[slice_idx * num_units * unit_factor_T_1 + idx]),
                    ptr_2(&m.ptr_2[slice_idx * num_units * unit_factor_T_2 + idx]),
                    ptr_3(&m.ptr_3[slice_idx * num_units * unit_factor_T_3 + idx])
                { ; }

                memory at(const std::size_t slice_idx, const std::size_t idx)
                {
                    return memory(*this, slice_idx, idx);
                }

                memory at(const std::size_t slice_idx, const std::size_t idx) const
                {
                    return memory(*this, slice_idx, idx);
                }

                // replace by internal alignment
                static std::size_t padding(const std::size_t n, const std::size_t alignment = SIMD_NAMESPACE::simd::alignment)
                {
                    if (!MISC_NAMESPACE::is_power_of<2>(alignment))
                    {
                        std::cerr << "warning: alignment is not a power of 2" << std::endl;
                        return n;
                    }

                    const std::size_t byte_padding_factor = std::max(1UL, alignment / size_largest_type);
                    const std::size_t ratio = (is_homogeneous ? byte_padding_factor : MISC_NAMESPACE::least_common_multiple(record_padding_factor, byte_padding_factor));

                    return ((n + ratio - 1) / ratio) * ratio;
                }

                template <std::size_t D>
                static std::uint8_t* allocate(const sarray<std::size_t, D>& n, const std::size_t alignment = SIMD_NAMESPACE::simd::alignment)
                {
                    if (n[0] != padding(n[0], alignment))
                    {
                        std::cerr << "error in vec_proxy::memory::allocate : n[0] does not match alignment" << std::endl;
                    }

                    return reinterpret_cast<std::uint8_t*>(_mm_malloc(n.reduce_mul() * record_size, alignment));
                }

                static void deallocate(memory& m)
                {
                    if (m.ptr_1)
                    {
                        _mm_free(reinterpret_cast<std::uint8_t*>(m.ptr_1));
                    }
                }
            };

            tuple_proxy(memory m)
                :
                x(*(m.ptr_1)),
                y(*(m.ptr_2)),
                z(*(m.ptr_3))
            { ; }

            template <typename X>
			tuple_proxy& operator=(const X xyz)
			{
				x = xyz;
				y = xyz;
				z = xyz;
				return *this;
			}

            T_1& x;
            T_2& y;
            T_3& z;
        };

        template <typename T_1, typename T_2, typename T_3>
        std::ostream& operator<<(std::ostream& os, const tuple_proxy<T_1, T_2, T_3>& vp)
        {
            os << "(" << static_cast<std::uint64_t>(vp.x) << "," << static_cast<std::uint64_t>(vp.y) << "," << static_cast<std::uint64_t>(vp.z) << ")";
            return os;
        }
    }
}

namespace XXX_NAMESPACE
{
    namespace internal
    {
        template <typename T_1, typename T_2, typename T_3>
        struct provides_proxy_type<TUPLE_NAMESPACE::tuple<T_1, T_2, T_3>>
        {
            static constexpr bool value = true;
        };

        template <typename T_1, typename T_2, typename T_3>
        struct provides_proxy_type<const TUPLE_NAMESPACE::tuple<T_1, T_2, T_3>>
        {
            static constexpr bool value = true;
        };
    }
}

#endif