// Copyright (c) 2017-2019 Florian Wende (flwende@gmail.com)
//
// Distributed under the BSD 2-clause Software License
// (See accompanying file LICENSE)

#if !defined(DATA_TYPES_TUPLE_TUPLE_PROXY_HPP)
#define DATA_TYPES_TUPLE_TUPLE_PROXY_HPP

#if defined(OLD)

#include <type_traits>

#if !defined(XXX_NAMESPACE)
#define XXX_NAMESPACE fw
#endif

#include <common/DataLayout.hpp>
#include <data_types/DataTypes.hpp>
#include <data_types/tuple/Tuple.hpp>
#include <common/Memory.hpp>
#include <auxiliary/Template.hpp>

namespace XXX_NAMESPACE
{
    namespace dataTypes
    {
        namespace internal 
        {
            
            template <typename, SizeT, SizeT, ::XXX_NAMESPACE::memory::DataLayout>
            class Accessor;
        
            template <typename ...T>
            class TupleProxy;

            template <typename T_1, typename T_2, typename T_3>
            class TupleProxy<T_1, T_2, T_3>
            {
                static_assert(::XXX_NAMESPACE::variadic::Pack<T_1, T_2, T_3>::IsFundamental(), "error: fundamental parameter types assumed.");
                static_assert(!::XXX_NAMESPACE::variadic::Pack<T_1, T_2, T_3>::IsVoid(), "error: non-void parameter types assumed.");
                static_assert(!::XXX_NAMESPACE::variadic::Pack<T_1, T_2, T_3>::IsVolatile(), "error: non-volatile parameter types assumed.");

                template <typename ...T>
                using Pack = ::XXX_NAMESPACE::variadic::Pack<T...>;
                template <typename ...T>
                using Tuple = ::XXX_NAMESPACE::dataTypes::Tuple<T...>;
                using T_1_Unqualified = std::decay_t<T_1>;
                using T_2_Unqualified = std::decay_t<T_2>;
                using T_3_Unqualified = std::decay_t<T_3>;

                static constexpr bool IsConstType = Pack<T_1, T_2, T_3>::IsConst();
                static constexpr bool IsHomogeneous = Pack<T_1, T_2, T_3>::IsSame() || Pack<T_1, T_2, T_3>::SameSize();

                template <typename, SizeT, SizeT, ::XXX_NAMESPACE::memory::DataLayout>
                friend class ::XXX_NAMESPACE::dataTypes::internal::Accessor;

            public:

                // some meta data: to be generated by the proxy generator
                using T = TupleProxy<T_1, T_2, T_3>;
                using ConstT = const TupleProxy<const T_1, const T_2, const T_3>;
                using BasePointer = std::conditional_t<IsHomogeneous, ::XXX_NAMESPACE::memory::Pointer<T_1, T_2, T_3>, ::XXX_NAMESPACE::memory::MultiPointer<T_1, T_2, T_3>>;
                using BaseT = typename std::conditional<IsConstType, const Tuple<T_1_Unqualified, T_2_Unqualified, T_3_Unqualified>, Tuple<T_1_Unqualified, T_2_Unqualified, T_3_Unqualified>>::type;

                T_1& x;
                T_2& y;
                T_3& z;
                
            private:

                HOST_VERSION
                CUDA_DEVICE_VERSION
                TupleProxy(std::tuple<T_1&, T_2&, T_3&> t)
                    :
                    x(std::get<0>(t)),
                    y(std::get<1>(t)),
                    z(std::get<2>(t)) {}
                 
            public:
                
            #define MACRO(OP, IN_T)                                                                 \
                inline TupleProxy& operator OP (::XXX_NAMESPACE::dataTypes::IN_T<T_1, T_2, T_3>& t)           \
                {                                                                                   \
                    x OP t.x;                                                                       \
                    y OP t.y;                                                                       \
                    z OP t.z;                                                                       \
                    return *this;                                                                   \
                }                                                                                   \
                                                                                                    \
                inline TupleProxy& operator OP (const ::XXX_NAMESPACE::dataTypes::IN_T<T_1, T_2, T_3>& t)     \
                {                                                                                   \
                    x OP t.x;                                                                       \
                    y OP t.y;                                                                       \
                    z OP t.z;                                                                       \
                    return *this;                                                                   \
                }                                                                                   \
                                                                                                    \
                template <typename X_1, typename X_2, typename X_3>                                 \
                inline TupleProxy& operator OP (::XXX_NAMESPACE::dataTypes::IN_T<X_1, X_2, X_3>& t)           \
                {                                                                                   \
                    x OP t.x;                                                                       \
                    y OP t.y;                                                                       \
                    z OP t.z;                                                                       \
                    return *this;                                                                   \
                }                                                                                   \
                                                                                                    \
                template <typename X_1, typename X_2, typename X_3>                                 \
                inline TupleProxy& operator OP (const ::XXX_NAMESPACE::dataTypes::IN_T<X_1, X_2, X_3>& t)     \
                {                                                                                   \
                    x OP t.x;                                                                       \
                    y OP t.y;                                                                       \
                    z OP t.z;                                                                       \
                    return *this;                                                                   \
                }                                                                                   \

                MACRO(=, Tuple)
                MACRO(+=, Tuple)
                MACRO(-=, Tuple)
                MACRO(*=, Tuple)
                MACRO(/=, Tuple)

                MACRO(=, internal::TupleProxy)
                MACRO(+=, internal::TupleProxy)
                MACRO(-=, internal::TupleProxy)
                MACRO(*=, internal::TupleProxy)
                MACRO(/=, internal::TupleProxy)

            #undef MACRO

            #define MACRO(OP)                                                                       \
                template <typename X>                                                               \
                inline TupleProxy& operator OP (const X xyz)                                       \
                {                                                                                   \
                    x OP xyz;                                                                       \
                    y OP xyz;                                                                       \
                    z OP xyz;                                                                       \
                    return *this;                                                                   \
                }                                                                                   \

                MACRO(=)
                MACRO(+=)
                MACRO(-=)
                MACRO(*=)
                MACRO(/=)

            #undef MACRO
            };

            template <typename T_1, typename T_2, typename T_3>
            std::ostream& operator<<(std::ostream& os, const TupleProxy<T_1, T_2, T_3>& vp)
            {
                os << "(" << vp.x << "," << vp.y << "," << vp.z << ")";
                return os;
            }
        }
    }
}

#else

#include <type_traits>

#if !defined(XXX_NAMESPACE)
#define XXX_NAMESPACE fw
#endif

#include <common/DataLayout.hpp>
#include <data_types/DataTypes.hpp>
#include <data_types/tuple/Tuple.hpp>
#include <data_types/integer_sequence/IntegerSequence.hpp>
#include <common/Memory.hpp>
#include <auxiliary/Template.hpp>

namespace XXX_NAMESPACE
{
    namespace dataTypes
    {
        namespace internal 
        {
            template <typename, SizeT, SizeT, ::XXX_NAMESPACE::memory::DataLayout>
            class Accessor;
        
            template <typename ...ValueT>
            class TupleProxy : public ::XXX_NAMESPACE::dataTypes::Tuple<ValueT&...>
            {
                using Base = ::XXX_NAMESPACE::dataTypes::Tuple<ValueT&...>;

                //static_assert(::XXX_NAMESPACE::variadic::Pack<ValueT...>::IsFundamental(), "error: fundamental parameter types assumed.");
                static_assert(!::XXX_NAMESPACE::variadic::Pack<ValueT...>::IsVoid(), "error: non-void parameter types assumed.");
                static_assert(!::XXX_NAMESPACE::variadic::Pack<ValueT...>::IsVolatile(), "error: non-volatile parameter types assumed.");

                template <typename ...T>
                using Pack = ::XXX_NAMESPACE::variadic::Pack<T...>;
                template <typename ...T>
                using Tuple = ::XXX_NAMESPACE::dataTypes::Tuple<T...>;
                
                static constexpr bool IsConstType = Pack<ValueT...>::IsConst();
                static constexpr bool IsHomogeneous = Pack<ValueT...>::SameSize();

                template <typename, SizeT, SizeT, ::XXX_NAMESPACE::memory::DataLayout>
                friend class ::XXX_NAMESPACE::dataTypes::internal::Accessor;

                template <SizeT ...I>
                HOST_VERSION
                CUDA_DEVICE_VERSION
                TupleProxy(std::tuple<ValueT&...>&& tuple, ::XXX_NAMESPACE::dataTypes::IndexSequence<I...>)
                    :
                    Base(std::get<I>(tuple)...) {}

                HOST_VERSION
                CUDA_DEVICE_VERSION
                TupleProxy(std::tuple<ValueT&...> tuple)
                    :
                    TupleProxy(std::move(tuple), ::XXX_NAMESPACE::dataTypes::MakeIndexSequence<sizeof...(ValueT)>()) {}

            public:
                // some meta data: to be generated by the proxy generator
                using ConstT = const TupleProxy<const ValueT...>;
                using BasePointer = std::conditional_t<IsHomogeneous, ::XXX_NAMESPACE::memory::Pointer<ValueT...>, ::XXX_NAMESPACE::memory::MultiPointer<ValueT...>>;
                using BaseT = typename std::conditional<IsConstType, const Tuple<std::decay_t<ValueT>...>, Tuple<std::decay_t<ValueT>...>>::type;

                template <typename ...T>
                HOST_VERSION
                CUDA_DEVICE_VERSION
                inline auto operator=(const Tuple<T...>& tuple) -> TupleProxy&
                {
                    ::XXX_NAMESPACE::compileTime::Loop<sizeof...(ValueT)>::Execute([&tuple, this](const auto I) { internal::Get<I>(this->data) = internal::Get<I>(tuple.data); });

                    return *this;
                }
            };
        }
    }
}

#endif

#endif